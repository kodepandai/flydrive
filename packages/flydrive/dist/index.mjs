var x=Object.defineProperty;var a=(r,t)=>x(r,"name",{value:t,configurable:!0});import{RuntimeException as u}from"node-exceptions";import*as n from"fs-extra";import{promises as j}from"fs";import{resolve as M,join as w,sep as y,dirname as N,relative as F}from"path";import{promisify as C}from"util";import{pipeline as T}from"stream";var U=Object.defineProperty,R=a((r,t)=>U(r,"name",{value:t,configurable:!0}),"e$1");class $ extends u{constructor(t,e){super(`Unauthorized to access file ${e}
${t.message}`,500,"E_AUTHORIZATION_REQUIRED"),this.raw=t}}a($,"AuthorizationRequired"),R($,"AuthorizationRequired");var A=Object.defineProperty,L=a((r,t)=>A(r,"name",{value:t,configurable:!0}),"o$4");class p extends u{static driver(t){const e=new this(`Driver ${t} is not supported`,400);return e.driver=t,e}}a(p,"DriverNotSupported"),L(p,"DriverNotSupported");var G=Object.defineProperty,B=a((r,t)=>G(r,"name",{value:t,configurable:!0}),"t$1");class l extends u{constructor(t,e){super(`The file ${e} doesn't exist
${t.message}`,500,"E_FILE_NOT_FOUND"),this.raw=t}}a(l,"FileNotFound"),B(l,"FileNotFound");var W=Object.defineProperty,z=a((r,t)=>W(r,"name",{value:t,configurable:!0}),"n$3");class h extends u{static missingDiskName(){return new this("Make sure to define a default disk name inside config file",500,"E_INVALID_CONFIG")}static missingDiskConfig(t){return new this(`Make sure to define config for ${t} disk`,500,"E_INVALID_CONFIG")}static missingDiskDriver(t){return new this(`Make sure to define driver for ${t} disk`,500,"E_INVALID_CONFIG")}static duplicateDiskName(t){return new this(`A disk named ${t} is already defined`,500,"E_INVALID_CONFIG")}}a(h,"InvalidConfig"),z(h,"InvalidConfig");var H=Object.defineProperty,K=a((r,t)=>H(r,"name",{value:t,configurable:!0}),"e");class i extends u{constructor(t,e){super(`Method ${t} is not supported for the driver ${e}`,500,"E_METHOD_NOT_SUPPORTED")}}a(i,"MethodNotSupported"),K(i,"MethodNotSupported");var V=Object.defineProperty,q=a((r,t)=>V(r,"name",{value:t,configurable:!0}),"s$2");class k extends u{constructor(t,e){super(`The bucket ${e} doesn't exist
${t.message}`,500,"E_NO_SUCH_BUCKET"),this.raw=t}}a(k,"NoSuchBucket"),q(k,"NoSuchBucket");var Q=Object.defineProperty,Y=a((r,t)=>Q(r,"name",{value:t,configurable:!0}),"o$3");class m extends u{constructor(t,e){super(`Missing permission for file ${e}
${t.message}`,500,"E_PERMISSION_MISSING"),this.raw=t}}a(m,"PermissionMissing"),Y(m,"PermissionMissing");var Z=Object.defineProperty,J=a((r,t)=>Z(r,"name",{value:t,configurable:!0}),"s$1");class g extends u{constructor(t,e,s){super(`An unknown error happened with the file ${s}.
Please open an issue at https://github.com/kodepandai/flydrive/issues

Error code: ${e}
Original stack:
${t.stack}`,500,"E_UNKNOWN"),this.raw=t}}a(g,"UnknownException"),J(g,"UnknownException");var X=Object.defineProperty,tt=a((r,t)=>X(r,"name",{value:t,configurable:!0}),"s");class P extends u{constructor(t,e){super(`The key path does not exist: ${e}
${t.message}`,500,"E_WRONG_KEY_PATH"),this.raw=t}}a(P,"WrongKeyPath"),tt(P,"WrongKeyPath");var et=Object.defineProperty,O=a((r,t)=>et(r,"name",{value:t,configurable:!0}),"o$1");class f{append(t,e){throw new i("append",this.constructor.name)}copy(t,e){throw new i("copy",this.constructor.name)}delete(t){throw new i("delete",this.constructor.name)}driver(){throw new i("driver",this.constructor.name)}exists(t){throw new i("exists",this.constructor.name)}get(t,e){throw new i("get",this.constructor.name)}getBuffer(t){throw new i("getBuffer",this.constructor.name)}getSignedUrl(t,e){throw new i("getSignedUrl",this.constructor.name)}getStat(t){throw new i("getStat",this.constructor.name)}getStream(t){throw new i("getStream",this.constructor.name)}getUrl(t){throw new i("getUrl",this.constructor.name)}move(t,e){throw new i("move",this.constructor.name)}put(t,e,s){throw new i("put",this.constructor.name)}prepend(t,e){throw new i("prepend",this.constructor.name)}flatList(t){throw new i("flatList",this.constructor.name)}}a(f,"r"),O(f,"Storage");class E extends f{}a(E,"StorageInstance"),O(E,"StorageInstance");var rt=Object.defineProperty,st=a((r,t)=>rt(r,"name",{value:t,configurable:!0}),"o");function b(r){return r!==null&&typeof r=="object"&&typeof r.pipe=="function"&&typeof r._read=="function"&&typeof r._readableState=="object"&&r.readable!==!1}a(b,"isReadableStream"),st(b,"isReadableStream");const S=C(T);var at=Object.defineProperty,I=a((r,t)=>at(r,"name",{value:t,configurable:!0}),"h");function c(r,t){switch(r.code){case"ENOENT":return new l(r,t);case"EPERM":return new m(r,t);default:return new g(r,r.code,t)}}a(c,"i"),I(c,"handleError");class v extends f{constructor(t){super(),this.$root=M(t.root)}_fullPath(t){return w(this.$root,w(y,t))}async append(t,e){try{return{raw:await n.appendFile(this._fullPath(t),e)}}catch(s){throw c(s,t)}}async copy(t,e){try{return{raw:await n.copy(this._fullPath(t),this._fullPath(e))}}catch(s){throw c(s,`${t} -> ${e}`)}}async delete(t){try{return{raw:await n.unlink(this._fullPath(t)),wasDeleted:!0}}catch(e){const s=c(e,t);if(s instanceof l)return{raw:void 0,wasDeleted:!1};throw s}}driver(){return n}async exists(t){try{const e=await n.pathExists(this._fullPath(t));return{exists:e,raw:e}}catch(e){throw c(e,t)}}async get(t,e="utf-8"){try{const s=await n.readFile(this._fullPath(t),e);return{content:s,raw:s}}catch(s){throw c(s,t)}}async getBuffer(t){try{const e=await n.readFile(this._fullPath(t));return{content:e,raw:e}}catch(e){throw c(e,t)}}async getStat(t){try{const e=await n.stat(this._fullPath(t));return{size:e.size,modified:e.mtime,raw:e}}catch(e){throw c(e,t)}}getStream(t){return n.createReadStream(this._fullPath(t))}async move(t,e){try{return{raw:await n.move(this._fullPath(t),this._fullPath(e))}}catch(s){throw c(s,`${t} -> ${e}`)}}async prepend(t,e){try{const{content:s}=await this.get(t,"utf-8");return this.put(t,`${e}${s}`)}catch(s){if(s instanceof l)return this.put(t,e);throw s}}async put(t,e){const s=this._fullPath(t);try{if(b(e)){const o=N(s);await n.ensureDir(o);const d=n.createWriteStream(s);return await S(e,d),{raw:void 0}}return{raw:await n.outputFile(s,e)}}catch(o){throw c(o,t)}}flatList(t=""){const e=this._fullPath(t);return this._flatDirIterator(e,t)}async*_flatDirIterator(t,e){const s=t[t.length-1]===y?t:N(t);try{const o=await j.opendir(s);for await(const d of o){const _=w(s,d.name);_.startsWith(t)&&(d.isDirectory()?yield*this._flatDirIterator(w(_,y),e):d.isFile()&&(yield{raw:null,path:F(this.$root,_)}))}}catch(o){if(o.code!=="ENOENT")throw c(o,e)}}}a(v,"LocalFileSystemStorage"),I(v,"LocalFileSystemStorage");var it=Object.defineProperty,nt=a((r,t)=>it(r,"name",{value:t,configurable:!0}),"n");class D{constructor(t){this._disks=new Map,this._drivers=new Map,this.defaultDisk=t.default,this.disksConfig=t.disks||{},this.registerDriver("local",v)}getDisks(){return this._disks}getDrivers(){return this._drivers}disk(t){if(t=t||this.defaultDisk,!t)throw h.missingDiskName();if(this._disks.has(t))return this._disks.get(t);const e=this.disksConfig[t];if(!e)throw h.missingDiskConfig(t);if(!e.driver)throw h.missingDiskDriver(t);const s=this._drivers.get(e.driver);if(!s)throw p.driver(e.driver);const o=new s(e.config);return this._disks.set(t,o),o}addDisk(t,e){if(this.disksConfig[t])throw h.duplicateDiskName(t);this.disksConfig[t]=e}registerDriver(t,e){this._drivers.set(t,e)}}a(D,"a"),nt(D,"StorageManager");export{$ as AuthorizationRequired,p as DriverNotSupported,l as FileNotFound,h as InvalidConfig,v as LocalFileSystemStorage,i as MethodNotSupported,k as NoSuchBucket,m as PermissionMissing,f as Storage,D as StorageManager,g as UnknownException,P as WrongKeyPath,b as isReadableStream,S as pipeline};
